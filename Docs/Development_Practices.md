# 개발 실천 가이드라인 (Development Practices)

이 문서는 `DN_solution` 프로젝트에서 채택하고 있는 개발 실천 가이드라인을 상세하게 설명합니다. 코드 품질, 유지보수성, 확장성, 그리고 팀 협업을 위한 핵심 원칙들을 다룹니다.

## 1. 핵심 코딩 원칙

### 1.1. 단일 책임 원칙 (Single Responsibility Principle, SRP)

각 클래스, 함수, 모듈은 하나의 명확한 책임만을 가져야 합니다.

*   **모델 레벨:** `Company` 모델은 업체 정보 관리만 담당하고, `CompanyUser` 모델은 사용자 정보 관리만 담당합니다.
*   **뷰 레벨:** `CompanyViewSet`은 업체 관련 API 처리만 담당하고, `CompanyUserViewSet`은 사용자 관련 API 처리만 담당합니다.
*   **시리얼라이저 레벨:** 각 시리얼라이저는 특정 모델의 직렬화/역직렬화만 담당합니다.

### 1.2. GoF 디자인 패턴 활용

*   **ViewSet 패턴:** DRF의 `ViewSet`을 활용하여 CRUD 작업을 표준화합니다.
*   **Serializer 패턴:** 데이터 변환 로직을 시리얼라이저에 캡슐화합니다.
*   **Factory 패턴:** 객체 생성 로직을 별도 메서드로 분리합니다.

### 1.3. 애자일 개발 방법론 준수

*   **점진적 개발:** 작은 단위로 기능을 구현하고 테스트합니다.
*   **지속적 통합:** 코드 변경 시 즉시 테스트를 실행합니다.
*   **사용자 피드백:** 실제 사용자 요구사항에 기반한 개발을 진행합니다.

## 2. 클린 코드 원칙

### 2.1. 명확하고 의도적인 이름 지정

*   **변수명:** `company_type` 대신 `company_category` 사용을 고려하되, 일관성을 위해 기존 명명 규칙을 유지합니다.
*   **함수명:** `get_queryset()`은 명확하게 쿼리셋을 반환한다는 의도를 나타냅니다.
*   **클래스명:** `CompanyViewSet`은 업체 관련 뷰셋임을 명확히 나타냅니다.

### 2.2. 주석 작성 원칙

*   **`Why`를 설명하는 주석:** 코드의 의도와 비즈니스 로직을 설명합니다.
*   **복잡한 로직 주석:** 특히 권한 검증이나 비즈니스 규칙과 같은 복잡한 로직에 주석을 추가합니다.

```python
# 본사는 상위 업체를 가질 수 없습니다 (비즈니스 규칙)
if self.type == 'headquarters' and self.parent_company:
    raise ValidationError("본사는 상위 업체를 가질 수 없습니다.")
```

### 2.3. 로직의 단순화 및 복잡성 제한

*   **함수 길이:** 각 함수는 20-30줄 이내로 유지합니다.
*   **중첩 레벨:** if문 중첩은 3단계 이내로 제한합니다.
*   **조건문 단순화:** 복잡한 조건문은 별도 함수로 분리합니다.

## 3. 로깅 전략

### 3.1. 로깅 레벨 활용

*   **`DEBUG`:** 개발 중 상세한 디버깅 정보
*   **`INFO`:** 일반적인 시스템 동작 정보
*   **`WARNING`:** 잠재적 문제나 주의사항
*   **`ERROR`:** 오류 상황
*   **`CRITICAL`:** 심각한 시스템 오류

### 3.2. 구조화된 로깅

```python
logger.info(f"[CompanyViewSet.create] 업체 생성 요청 - 사용자: {user.username}, 데이터: {request.data}")
logger.warning(f"[CompanyViewSet.create] 본사 계정이 판매점 직접 생성을 시도 - 사용자: {user.username}")
logger.error(f"[CompanyViewSet.create] 업체 생성 중 오류 - 사용자: {user.username}, 오류: {str(e)}")
```

### 3.3. 로깅 설정

`settings.py`에서 각 앱별로 로거를 설정하여 로그를 체계적으로 관리합니다.

## 4. 엣지 케이스 및 예외 처리

### 4.1. 예상치 못한 상황 식별

*   **데이터 무결성:** 중복 데이터, 잘못된 참조 관계 등
*   **권한 오류:** 인증되지 않은 사용자, 권한 부족 등
*   **네트워크 오류:** API 호출 실패, 타임아웃 등
*   **시스템 오류:** 데이터베이스 연결 실패, 메모리 부족 등

### 4.2. 다층적 유효성 검증

*   **모델 레벨:** `clean()` 메서드를 통한 데이터베이스 저장 전 검증
*   **시리얼라이저 레벨:** API 요청 데이터의 형식 및 비즈니스 규칙 검증
*   **뷰 레벨:** 권한 검증 및 비즈니스 로직 검증

### 4.3. 중앙 집중식 오류 처리

DRF의 `EXCEPTION_HANDLER`를 커스터마이징하여 일관된 오류 응답을 제공합니다.

## 5. 확장성 고려

### 5.1. 기능적 확장

*   **새로운 업체 유형 추가:** `Company` 모델의 `type` 필드에 새로운 선택지 추가
*   **새로운 사용자 역할 추가:** `CompanyUser` 모델의 `role` 필드에 새로운 선택지 추가
*   **새로운 주문 상태 추가:** `Order` 모델의 상태 필드 확장

### 5.2. 데이터 확장

*   **새로운 필드 추가:** 기존 모델에 새로운 필드 추가 시 마이그레이션 고려
*   **새로운 모델 추가:** 새로운 비즈니스 도메인을 위한 새로운 앱 생성

### 5.3. 시스템 확장

*   **캐싱:** Redis를 활용한 데이터 캐싱
*   **비동기 처리:** Celery를 활용한 백그라운드 작업
*   **로드 밸런싱:** 다중 서버 환경에서의 부하 분산

## 6. 테스트 용이성

### 6.1. 독립적 테스트 가능한 설계

*   **의존성 주입:** 외부 의존성을 주입받아 테스트 시 모킹 가능
*   **단위 테스트:** 각 함수/메서드를 독립적으로 테스트 가능
*   **통합 테스트:** 여러 컴포넌트 간의 상호작용 테스트

### 6.2. 테스트 커버리지

*   **모델 테스트:** 데이터 유효성 검증 및 비즈니스 로직 테스트
*   **API 테스트:** 엔드포인트 동작 및 권한 검증 테스트
*   **시리얼라이저 테스트:** 데이터 변환 로직 테스트

## 7. 협업 및 일관성

### 7.1. PEP 8 준수

*   **들여쓰기:** 4칸 공백 사용
*   **줄 길이:** 79자 이내
*   **명명 규칙:** snake_case 사용

### 7.2. 코드 포매터/린터 사용

*   **Black:** 자동 코드 포매팅
*   **Flake8:** 코드 스타일 검사
*   **isort:** import 문 정렬

### 7.3. 통일된 명명 규칙

*   **모델명:** PascalCase (예: `Company`, `CompanyUser`)
*   **필드명:** snake_case (예: `company_name`, `parent_company`)
*   **함수명:** snake_case (예: `get_queryset`, `create`)
*   **상수명:** UPPER_CASE (예: `COMPANY_TYPES`)

## 8. 문제 해결 사례 및 교훈

### 8.1. 마이그레이션 충돌 해결 (2025-07-28)

**문제:** 기존 데이터에 새로운 필드(`code`)를 추가할 때 마이그레이션 충돌이 발생했습니다.

**해결 과정:**
1. 기존 데이터에 대한 기본값 설정
2. 마이그레이션 병합 (`python manage.py makemigrations --merge`)
3. 데이터베이스 초기화 후 재마이그레이션

**교훈:** 
- 기존 데이터가 있는 상태에서 스키마 변경 시 주의 필요
- 마이그레이션 충돌 시 병합보다는 데이터 초기화 후 재시작 고려
- 개발 단계에서는 데이터 손실을 감수하고 깔끔한 마이그레이션 진행

### 8.2. 계층별 승인 시스템 구현

**문제:** 상위 업체 코드 검증 로직이 복잡하고 에러 처리가 어려웠습니다.

**해결 과정:**
1. 모델 레벨에서 `clean()` 메서드로 기본 검증
2. API 레벨에서 구체적인 에러 메시지 제공
3. 프론트엔드에서 동적 UI로 사용자 경험 개선

**교훈:**
- 비즈니스 로직은 모델 레벨에서 우선 검증
- API 레벨에서는 사용자 친화적인 에러 메시지 제공
- 프론트엔드와 백엔드의 협력으로 완성도 높은 기능 구현

### 8.3. 로그인/회원가입 문제 해결

**문제:** 로그인 후 페이지 전환이 안 되고 백엔드 로그가 나타나지 않는 문제가 발생했습니다.

**해결 과정:**
1. 프론트엔드 API 요청 로깅 추가
2. 백엔드 에러 처리 개선
3. CORS 설정 확인 및 수정
4. 가상환경 활성화 확인

**교훈:**
- 문제 발생 시 로깅을 통한 체계적 디버깅 필요
- 프론트엔드와 백엔드 간의 에러 메시지 전달 체계 구축
- 개발 환경 설정(가상환경, CORS 등)의 중요성

## 9. 성능 최적화 고려사항

### 9.1. 데이터베이스 최적화

*   **인덱스 활용:** 자주 조회되는 필드에 인덱스 추가
*   **쿼리 최적화:** N+1 쿼리 문제 방지를 위한 `select_related`, `prefetch_related` 활용
*   **페이지네이션:** 대용량 데이터 조회 시 페이지네이션 적용

### 9.2. API 응답 최적화

*   **필드 선택:** 필요한 필드만 반환하도록 시리얼라이저 조정
*   **캐싱:** 자주 조회되는 데이터에 대한 캐싱 적용
*   **압축:** 대용량 응답에 대한 압축 적용

## 10. 보안 고려사항

### 10.1. 인증 및 권한

*   **세션 기반 인증:** Django의 세션 기반 인증 활용
*   **권한 검증:** 모든 API에서 권한 검증 수행
*   **CSRF 보호:** POST 요청에 대한 CSRF 토큰 검증

### 10.2. 데이터 보안

*   **비밀번호 해싱:** Django의 기본 비밀번호 해싱 활용
*   **민감 정보 보호:** 로그에 민감한 정보 노출 방지
*   **입력 검증:** 모든 사용자 입력에 대한 검증 수행

이 문서는 `DN_solution` 프로젝트의 개발 품질을 보장하고 팀 협업을 원활하게 하기 위한 핵심 가이드라인을 제공합니다.
